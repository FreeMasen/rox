
running 1 test
visit: Env { values: ChainMap { maps: [{}] } }
visit: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{}] } }, env_idx: 1 })}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{}] } }, env_idx: 1 })}] } }
call: Env { values: ChainMap { maps: [{}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{}] } }, env_idx: 1 })}, {"n": Number(4.0)}, {}] } }
call: Env { values: ChainMap { maps: [{}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{}] } }, env_idx: 1 })}, {"n": Number(3.0)}, {}] } }
call: Env { values: ChainMap { maps: [{}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{}] } }, env_idx: 1 })}, {"n": Number(2.0)}, {}] } }
call: Env { values: ChainMap { maps: [{}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{"n": Number(1.0)}] } }, env_idx: 1 })}, {"n": Number(1.0)}, {"n": Number(2.0)}, {}] } }
call: Env { values: ChainMap { maps: [{"n": Number(1.0)}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}] } }, env_idx: 1 })}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}, {}] } }
call: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}] } }, env_idx: 1 })}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}, {"n": Number(4.0)}, {}] } }
call: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}] } }, env_idx: 1 })}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(2.0)}, {}] } }
call: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(3.0)}] } }
call: Env { values: ChainMap { maps: [{"mod": NativeFunc(Mod(Mod)), "clock": NativeFunc(Clock(Clock))}, {"fib": Func(Func { name: "fib", params: ["n"], body: [If { test: Binary { left: Var("n"), operator: Token { kind: Less, lexeme: "<", line: 3, span: (40, 41) }, right: Literal(Number(2.0)) }, consequence: Return(Some(Var("n"))), alternate: None }, Return(Some(Binary { left: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (80, 81) }, right: Literal(Number(1.0)) }] }, operator: Token { kind: Plus, lexeme: "+", line: 4, span: (85, 86) }, right: Call { callee: Var("fib"), arguments: [Binary { left: Var("n"), operator: Token { kind: Minus, lexeme: "-", line: 4, span: (93, 94) }, right: Literal(Number(2.0)) }] } }))], env: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(1.0)}] } }, env_idx: 1 })}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(2.0)}, {}] } }
call: Env { values: ChainMap { maps: [{"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(1.0)}, {"n": Number(0.0)}, {"n": Number(1.0)}, {"n": Number(2.0)}, {"n": Number(1.0)}] } }
test func::test::recursive ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

